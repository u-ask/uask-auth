import {
  ref,
  getCurrentInstance,
  computed,
  watch,
  createVNode,
  Text,
  h,
  Fragment,
  inject,
  onMounted,
  onUnmounted,
  isRef,
} from "./vue.runtime.esm-browser.min.js";
const inBrowser = "undefined" != typeof window;
let mark, measure;
{
  const a = inBrowser && window.performance;
  a &&
    a.mark &&
    a.measure &&
    a.clearMarks &&
    a.clearMeasures &&
    ((mark = e => a.mark(e)),
    (measure = (e, t, n) => {
      a.measure(e, t, n), a.clearMarks(t), a.clearMarks(n);
    }));
}
const RE_ARGS = /\{([0-9a-zA-Z]+)\}/g;
function format(e, ...a) {
  return (
    ((a = 1 === a.length && isObject(a[0]) ? a[0] : a) && a.hasOwnProperty) ||
      (a = {}),
    e.replace(RE_ARGS, (e, t) => (a.hasOwnProperty(t) ? a[t] : ""))
  );
}
const hasSymbol =
    "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag,
  makeSymbol = e => (hasSymbol ? Symbol(e) : e),
  generateFormatCacheKey = (e, t, a) =>
    friendlyJSONstringify({ l: e, k: t, s: a }),
  friendlyJSONstringify = e =>
    JSON.stringify(e)
      .replace(/\u2028/g, "\\u2028")
      .replace(/\u2029/g, "\\u2029")
      .replace(/\u0027/g, "\\u0027"),
  isNumber = e => "number" == typeof e && isFinite(e),
  isDate = e => "[object Date]" === toTypeString(e),
  isRegExp = e => "[object RegExp]" === toTypeString(e),
  isEmptyObject = e => isPlainObject(e) && 0 === Object.keys(e).length;
function warn(e, t) {
  "undefined" != typeof console &&
    (console.warn("[intlify] " + e), t && console.warn(t.stack));
}
const assign = Object.assign;
let _globalThis;
const getGlobalThis = () =>
  (_globalThis =
    _globalThis ||
    ("undefined" != typeof globalThis
      ? globalThis
      : "undefined" != typeof self
      ? self
      : "undefined" != typeof window
      ? window
      : "undefined" != typeof global
      ? global
      : {}));
function escapeHtml(e) {
  return e
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&apos;");
}
const hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn(e, t) {
  return hasOwnProperty.call(e, t);
}
const isArray = Array.isArray,
  isFunction = e => "function" == typeof e,
  isString = e => "string" == typeof e,
  isBoolean = e => "boolean" == typeof e,
  isObject = e => null !== e && "object" == typeof e,
  objectToString = Object.prototype.toString,
  toTypeString = e => objectToString.call(e),
  isPlainObject = e => "[object Object]" === toTypeString(e),
  toDisplayString = e =>
    null == e
      ? ""
      : isArray(e) || (isPlainObject(e) && e.toString === objectToString)
      ? JSON.stringify(e, null, 2)
      : String(e),
  RANGE = 2;
function generateCodeFrame(e, a = 0, n = e.length) {
  var r,
    s,
    o,
    i = e.split(/\r?\n/);
  let l = 0;
  const c = [];
  for (let t = 0; t < i.length; t++)
    if ((l += i[t].length + 1) >= a) {
      for (let e = t - RANGE; e <= t + RANGE || n > l; e++)
        e < 0 ||
          e >= i.length ||
          ((r = e + 1),
          c.push("" + r + " ".repeat(3 - String(r).length) + "|  " + i[e]),
          (r = i[e].length),
          e === t
            ? ((o = a - (l - r) + 1),
              (s = Math.max(1, n > l ? r - o : n - a)),
              c.push("   |  " + " ".repeat(o) + "^".repeat(s)))
            : e > t &&
              (n > l &&
                ((o = Math.max(Math.min(n - l, r), 1)),
                c.push("   |  " + "^".repeat(o))),
              (l += r + 1)));
      break;
    }
  return c.join("\n");
}
function createEmitter() {
  const n = new Map();
  return {
    events: n,
    on(e, t) {
      const a = n.get(e);
      (a && a.push(t)) || n.set(e, [t]);
    },
    off(e, t) {
      const a = n.get(e);
      a && a.splice(a.indexOf(t) >>> 0, 1);
    },
    emit(t, a) {
      (n.get(t) || []).slice().map(e => e(a)),
        (n.get("*") || []).slice().map(e => e(t, a));
    },
  };
}
const pathStateMachine = [],
  literalValueRE =
    ((pathStateMachine[0] = { w: [0], i: [3, 0], "[": [4], o: [7] }),
    (pathStateMachine[1] = { w: [1], ".": [2], "[": [4], o: [7] }),
    (pathStateMachine[2] = { w: [2], i: [3, 0], [0]: [3, 0] }),
    (pathStateMachine[3] = {
      i: [3, 0],
      [0]: [3, 0],
      w: [1, 1],
      ".": [2, 1],
      "[": [4, 1],
      o: [7, 1],
    }),
    (pathStateMachine[4] = {
      "'": [5, 0],
      '"': [6, 0],
      "[": [4, 2],
      "]": [1, 3],
      o: 8,
      l: [4, 0],
    }),
    (pathStateMachine[5] = { "'": [4, 0], o: 8, l: [5, 0] }),
    (pathStateMachine[6] = { '"': [4, 0], o: 8, l: [6, 0] }),
    /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/);
function isLiteral(e) {
  return literalValueRE.test(e);
}
function stripQuotes(e) {
  var t = e.charCodeAt(0);
  return t !== e.charCodeAt(e.length - 1) || (34 !== t && 39 !== t)
    ? e
    : e.slice(1, -1);
}
function getPathCharType(e) {
  if (null == e) return "o";
  switch (e.charCodeAt(0)) {
    case 91:
    case 93:
    case 46:
    case 34:
    case 39:
      return e;
    case 95:
    case 36:
    case 45:
      return "i";
    case 9:
    case 10:
    case 13:
    case 160:
    case 65279:
    case 8232:
    case 8233:
      return "w";
  }
  return "i";
}
function formatSubPath(e) {
  var t = e.trim();
  return (
    ("0" !== e.charAt(0) || !isNaN(parseInt(e))) &&
    (isLiteral(t) ? stripQuotes(t) : "*" + t)
  );
}
function parse(e) {
  const t = [];
  let a = -1,
    n = 0,
    r = 0;
  var s, o, i;
  let l, c, u;
  const m = [];
  for (
    m[0] = () => {
      void 0 === l ? (l = c) : (l += c);
    },
      m[1] = () => {
        void 0 !== l && (t.push(l), (l = void 0));
      },
      m[2] = () => {
        m[0](), r++;
      },
      m[3] = () => {
        if (!(0 < r))
          return (
            void (r = 0) !== l && !1 !== (l = formatSubPath(l)) && void m[1]()
          );
        r--, (n = 4), m[0]();
      };
    null !== n;

  )
    if (
      (a++,
      "\\" !== (s = e[a]) ||
        ((i = void 0),
        (i = e[a + 1]),
        !((5 === n && "'" === i) || (6 === n && '"' === i)) ||
          (a++, (c = "\\" + i), m[0](), 0)))
    ) {
      if (
        ((i = getPathCharType(s)),
        8 === (o = (o = pathStateMachine[n])[i] || o.l || 8))
      )
        return;
      if (
        ((n = o[0]), void 0 !== o[1] && (u = m[o[1]]) && ((c = s), !1 === u()))
      )
        return;
      if (7 === n) return t;
    }
}
const cache = new Map();
function resolveValue(e, t) {
  if (!isObject(e)) return null;
  let a = cache.get(t);
  if ((a || ((a = parse(t)) && cache.set(t, a)), !a)) return null;
  var n = a.length;
  let r = e,
    s = 0;
  for (; s < n; ) {
    var o = r[a[s]];
    if (void 0 === o) return null;
    (r = o), s++;
  }
  return r;
}
function handleFlatJson(e) {
  if (!isObject(e)) return e;
  for (const r in e)
    if (hasOwn(e, r))
      if (r.includes(".")) {
        var a = r.split("."),
          n = a.length - 1;
        let t = e;
        for (let e = 0; e < n; e++) a[e] in t || (t[a[e]] = {}), (t = t[a[e]]);
        (t[a[n]] = e[r]),
          delete e[r],
          isObject(t[a[n]]) && handleFlatJson(t[a[n]]);
      } else isObject(e[r]) && handleFlatJson(e[r]);
  return e;
}
const DEFAULT_MODIFIER = e => e,
  DEFAULT_MESSAGE = e => "",
  DEFAULT_MESSAGE_DATA_TYPE = "text",
  DEFAULT_NORMALIZE = e => (0 === e.length ? "" : e.join("")),
  DEFAULT_INTERPOLATE = toDisplayString;
function pluralDefault(e, t) {
  return (
    (e = Math.abs(e)), 2 === t ? (!e || 1 < e ? 1 : 0) : e ? Math.min(e, 2) : 0
  );
}
function getPluralIndex(e) {
  var t = isNumber(e.pluralIndex) ? e.pluralIndex : -1;
  return e.named && (isNumber(e.named.count) || isNumber(e.named.n))
    ? isNumber(e.named.count)
      ? e.named.count
      : isNumber(e.named.n)
      ? e.named.n
      : t
    : t;
}
function normalizeNamed(e, t) {
  t.count || (t.count = e), t.n || (t.n = e);
}
function createMessageContext(a = {}) {
  var e = a.locale;
  const t = getPluralIndex(a),
    n =
      isObject(a.pluralRules) && isString(e) && isFunction(a.pluralRules[e])
        ? a.pluralRules[e]
        : pluralDefault,
    r =
      isObject(a.pluralRules) && isString(e) && isFunction(a.pluralRules[e])
        ? pluralDefault
        : void 0;
  const s = a.list || [];
  const o = a.named || {};
  isNumber(a.pluralIndex) && normalizeNamed(t, o);
  function i(e) {
    var t = isFunction(a.messages)
      ? a.messages(e)
      : !!isObject(a.messages) && a.messages[e];
    return t || (a.parent ? a.parent.message(e) : DEFAULT_MESSAGE);
  }
  var e =
      isPlainObject(a.processor) && isFunction(a.processor.normalize)
        ? a.processor.normalize
        : DEFAULT_NORMALIZE,
    l =
      isPlainObject(a.processor) && isFunction(a.processor.interpolate)
        ? a.processor.interpolate
        : DEFAULT_INTERPOLATE;
  const c = {
    list: e => s[e],
    named: e => o[e],
    plural: e => e[n(t, e.length, r)],
    linked: (e, t) => {
      e = i(e)(c);
      return isString(t)
        ? ((t = t), (a.modifiers ? a.modifiers[t] : DEFAULT_MODIFIER)(e))
        : e;
    },
    message: i,
    type:
      isPlainObject(a.processor) && isString(a.processor.type)
        ? a.processor.type
        : DEFAULT_MESSAGE_DATA_TYPE,
    interpolate: l,
    normalize: e,
  };
  return c;
}
const errorMessages$2 = {
  [0]: "Expected token: '{0}'",
  1: "Invalid token in placeholder: '{0}'",
  2: "Unterminated single quote in placeholder",
  3: "Unknown escape sequence: \\{0}",
  4: "Invalid unicode escape sequence: {0}",
  5: "Unbalanced closing brace",
  6: "Unterminated closing brace",
  7: "Empty placeholder",
  8: "Not allowed nest placeholder",
  9: "Invalid linked format",
  10: "Plural must have messages",
  11: "Unexpected empty linked modifier",
  12: "Unexpected empty linked key",
  13: "Unexpected lexical analysis in token: '{0}'",
};
function createCompileError(e, t, a = {}) {
  var { domain: a, messages: n, args: r } = a,
    n = format((n || errorMessages$2)[e] || "", ...(r || []));
  const s = new SyntaxError(String(n));
  return (s.code = e), t && (s.location = t), (s.domain = a), s;
}
const IntlifyDevToolsHooks = {
  I18nInit: "i18n:init",
  FunctionTranslate: "function:translate",
};
let devtools = null;
function setDevToolsHook(e) {
  devtools = e;
}
function initI18nDevTools(e, t, a) {
  devtools &&
    devtools.emit(IntlifyDevToolsHooks.I18nInit, {
      timestamp: Date.now(),
      i18n: e,
      version: t,
      meta: a,
    });
}
const translateDevTools = createDevToolsHook(
  IntlifyDevToolsHooks.FunctionTranslate
);
function createDevToolsHook(t) {
  return e => devtools && devtools.emit(t, e);
}
const warnMessages$1 = {
  [0]: "Not found '{key}' key in '{locale}' locale messages.",
  1: "Fall back to translate '{key}' key with '{target}' locale.",
  2: "Cannot format a number value due to not supported Intl.NumberFormat.",
  3: "Fall back to number format '{key}' key with '{target}' locale.",
  4: "Cannot format a date value due to not supported Intl.DateTimeFormat.",
  5: "Fall back to datetime format '{key}' key with '{target}' locale.",
};
function getWarnMessage$1(e, ...t) {
  return format(warnMessages$1[e], ...t);
}
const VERSION$1 = "9.1.10",
  NOT_REOSLVED = -1,
  MISSING_RESOLVE_VALUE = "";
function getDefaultLinkedModifiers() {
  return {
    upper: e => (isString(e) ? e.toUpperCase() : e),
    lower: e => (isString(e) ? e.toLowerCase() : e),
    capitalize: e =>
      isString(e) ? "" + e.charAt(0).toLocaleUpperCase() + e.substr(1) : e,
  };
}
let _compiler,
  _additionalMeta = null;
const setAdditionalMeta = e => {
    _additionalMeta = e;
  },
  getAdditionalMeta = () => _additionalMeta;
let _cid = 0;
function createCoreContext(e = {}) {
  var t = isString(e.version) ? e.version : VERSION$1,
    a = isString(e.locale) ? e.locale : "en-US",
    n =
      isArray(e.fallbackLocale) ||
      isPlainObject(e.fallbackLocale) ||
      isString(e.fallbackLocale) ||
      !1 === e.fallbackLocale
        ? e.fallbackLocale
        : a,
    r = isPlainObject(e.messages) ? e.messages : { [a]: {} },
    s = isPlainObject(e.datetimeFormats) ? e.datetimeFormats : { [a]: {} },
    o = isPlainObject(e.numberFormats) ? e.numberFormats : { [a]: {} },
    i = assign({}, e.modifiers || {}, getDefaultLinkedModifiers()),
    l = e.pluralRules || {},
    c = isFunction(e.missing) ? e.missing : null,
    u =
      (!isBoolean(e.missingWarn) && !isRegExp(e.missingWarn)) || e.missingWarn,
    m =
      (!isBoolean(e.fallbackWarn) && !isRegExp(e.fallbackWarn)) ||
      e.fallbackWarn,
    g = !!e.fallbackFormat,
    p = !!e.unresolving,
    f = isFunction(e.postTranslation) ? e.postTranslation : null,
    d = isPlainObject(e.processor) ? e.processor : null,
    b = !isBoolean(e.warnHtmlMessage) || e.warnHtmlMessage,
    _ = !!e.escapeParameter,
    v = isFunction(e.messageCompiler) ? e.messageCompiler : _compiler,
    y = isFunction(e.onWarn) ? e.onWarn : warn,
    h = isObject(e.__datetimeFormatters) ? e.__datetimeFormatters : new Map(),
    k = isObject(e.__numberFormatters) ? e.__numberFormatters : new Map(),
    S = isObject(e.__meta) ? e.__meta : {};
  const F = {
    version: t,
    cid: ++_cid,
    locale: a,
    fallbackLocale: n,
    messages: r,
    datetimeFormats: s,
    numberFormats: o,
    modifiers: i,
    pluralRules: l,
    missing: c,
    missingWarn: u,
    fallbackWarn: m,
    fallbackFormat: g,
    unresolving: p,
    postTranslation: f,
    processor: d,
    warnHtmlMessage: b,
    escapeParameter: _,
    messageCompiler: v,
    onWarn: y,
    __datetimeFormatters: h,
    __numberFormatters: k,
    __meta: S,
  };
  return (
    (F.__v_emitter = null != e.__v_emitter ? e.__v_emitter : void 0),
    initI18nDevTools(F, t, S),
    F
  );
}
function isTranslateFallbackWarn(e, t) {
  return e instanceof RegExp ? e.test(t) : e;
}
function isTranslateMissingWarn(e, t) {
  return e instanceof RegExp ? e.test(t) : e;
}
function handleMissing(e, t, a, n, r) {
  const { missing: s, onWarn: o } = e;
  {
    const i = e.__v_emitter;
    i &&
      i.emit("missing", { locale: a, key: t, type: r, groupId: r + ":" + t });
  }
  return null !== s
    ? ((e = s(e, a, t, r)), isString(e) ? e : t)
    : (isTranslateMissingWarn(n, t) &&
        o(getWarnMessage$1(0, { key: t, locale: a })),
      t);
}
function getLocaleChain(t, a, n) {
  const r = t;
  r.__localeChainCache || (r.__localeChainCache = new Map());
  let s = r.__localeChainCache.get(n);
  if (!s) {
    s = [];
    let e = [n];
    for (; isArray(e); ) e = appendBlockToChain(s, e, a);
    t = !isArray(a) && isPlainObject(a) ? a.default || null : a;
    (e = isString(t) ? [t] : t),
      isArray(e) && appendBlockToChain(s, e, !1),
      r.__localeChainCache.set(n, s);
  }
  return s;
}
function appendBlockToChain(t, a, n) {
  let r = !0;
  for (let e = 0; e < a.length && isBoolean(r); e++) {
    var s = a[e];
    isString(s) && (r = appendLocaleToChain(t, a[e], n));
  }
  return r;
}
function appendLocaleToChain(e, t, a) {
  let n;
  const r = t.split("-");
  do {
    var s = r.join("-");
    (n = appendItemToChain(e, s, a)), r.splice(-1, 1);
  } while (r.length && !0 === n);
  return n;
}
function appendItemToChain(e, t, a) {
  let n = !1;
  return (
    e.includes(t) ||
      ((n = !0),
      t &&
        ((n = "!" !== t[t.length - 1]),
        (t = t.replace(/!/g, "")),
        e.push(t),
        (isArray(a) || isPlainObject(a)) && a[t] && (n = a[t]))),
    n
  );
}
function updateFallbackLocale(e, t, a) {
  const n = e;
  (n.__localeChainCache = new Map()), getLocaleChain(e, a, t);
}
function createCoreError(e) {
  return createCompileError(e, null, { messages: errorMessages$1 });
}
const errorMessages$1 = {
    [14]: "Invalid arguments",
    15: "The date provided is an invalid Date object.Make sure your Date represents a valid date.",
    16: "The argument provided is not a valid ISO date string",
  },
  NOOP_MESSAGE_FUNCTION = () => "",
  isMessageFunction = e => isFunction(e);
function translate(e, ...t) {
  const {
    fallbackFormat: a,
    postTranslation: n,
    unresolving: r,
    fallbackLocale: s,
    messages: o,
  } = e;
  var [t, i] = parseTranslateArgs(...t),
    l = (isBoolean(i.missingWarn) ? i : e).missingWarn,
    c = (isBoolean(i.fallbackWarn) ? i : e).fallbackWarn,
    u = (isBoolean(i.escapeParameter) ? i : e).escapeParameter,
    m = !!i.resolvedMessage,
    g =
      isString(i.default) || isBoolean(i.default)
        ? isBoolean(i.default)
          ? t
          : i.default
        : a
        ? t
        : "",
    p = a || "" !== g,
    f = (isString(i.locale) ? i : e).locale;
  u && escapeParams(i);
  let [d, b, _] = m
      ? [t, f, o[f] || {}]
      : resolveMessageFormat(e, t, f, s, c, l),
    v = t;
  if (
    (m || isString(d) || isMessageFunction(d) || (p && ((d = g), (v = d))),
    !(m || ((isString(d) || isMessageFunction(d)) && isString(b))))
  )
    return r ? NOT_REOSLVED : t;
  if (isString(d) && null == e.messageCompiler)
    return (
      warn(
        "The message format compilation is not supported in this build. Because message compiler isn't included. You need to pre-compilation all message format. " +
          `So translate function return '${t}'.`
      ),
      t
    );
  let y = !1;
  u = isMessageFunction(d)
    ? d
    : compileMessageFormat(e, t, b, d, v, () => {
        y = !0;
      });
  if (y) return d;
  (f = evaluateMessage(
    e,
    u,
    createMessageContext(getMessageContextOptions(e, b, _, i))
  )),
    (c = n ? n(f) : f);
  {
    const h = {
      timestamp: Date.now(),
      key: isString(t) ? t : isMessageFunction(d) ? d.key : "",
      locale: b || (isMessageFunction(d) ? d.locale : ""),
      format: isString(d) ? d : isMessageFunction(d) ? d.source : "",
      message: c,
    };
    (h.meta = assign({}, e.__meta, getAdditionalMeta() || {})),
      translateDevTools(h);
  }
  return c;
}
function escapeParams(t) {
  isArray(t.list)
    ? (t.list = t.list.map(e => (isString(e) ? escapeHtml(e) : e)))
    : isObject(t.named) &&
      Object.keys(t.named).forEach(e => {
        isString(t.named[e]) && (t.named[e] = escapeHtml(t.named[e]));
      });
}
function resolveMessageFormat(r, s, o, e, i, l) {
  const { messages: c, onWarn: u } = r;
  var m = getLocaleChain(r, e, o);
  let g = {},
    p,
    f = null,
    d = o;
  var b,
    _ = "translate";
  for (let n = 0; n < m.length; n++) {
    if (
      (o !== (p = b = m[n]) &&
        isTranslateFallbackWarn(i, s) &&
        u(getWarnMessage$1(1, { key: s, target: p })),
      o !== p)
    ) {
      const y = r.__v_emitter;
      y &&
        y.emit("fallback", {
          type: _,
          key: s,
          from: d,
          to: b,
          groupId: _ + ":" + s,
        });
    }
    g = c[p] || {};
    let e = null,
      t,
      a;
    if (
      (inBrowser &&
        ((e = window.performance.now()),
        (t = "intlify-message-resolve-start"),
        (a = "intlify-message-resolve-end"),
        mark && mark(t)),
      null === (f = resolveValue(g, s)) && (f = g[s]),
      inBrowser)
    ) {
      var v = window.performance.now();
      const h = r.__v_emitter;
      h &&
        e &&
        f &&
        h.emit("message-resolve", {
          type: "message-resolve",
          key: s,
          message: f,
          time: v - e,
          groupId: _ + ":" + s,
        }),
        t &&
          a &&
          mark &&
          measure &&
          (mark(a), measure("intlify message resolve", t, a));
    }
    if (isString(f) || isFunction(f)) break;
    v = handleMissing(r, s, p, l, _);
    v !== s && (f = v), (d = b);
  }
  return [f, p, g];
}
function compileMessageFormat(e, t, a, n, r, s) {
  const { messageCompiler: o, warnHtmlMessage: i } = e;
  if (isMessageFunction(n)) {
    const m = n;
    return (m.locale = m.locale || a), (m.key = m.key || t), m;
  }
  let l = null,
    c,
    u;
  inBrowser &&
    ((l = window.performance.now()),
    (c = "intlify-message-compilation-start"),
    (u = "intlify-message-compilation-end"),
    mark && mark(c));
  const m = o(n, getCompileOptions(e, a, r, n, i, s));
  if (inBrowser) {
    r = window.performance.now();
    const g = e.__v_emitter;
    g &&
      l &&
      g.emit("message-compilation", {
        type: "message-compilation",
        message: n,
        time: r - l,
        groupId: "translate:" + t,
      }),
      c &&
        u &&
        mark &&
        measure &&
        (mark(u), measure("intlify message compilation", c, u));
  }
  return (m.locale = a), (m.key = t), (m.source = n), m;
}
function evaluateMessage(e, t, a) {
  let n = null,
    r,
    s;
  inBrowser &&
    ((n = window.performance.now()),
    (r = "intlify-message-evaluation-start"),
    (s = "intlify-message-evaluation-end"),
    mark && mark(r));
  a = t(a);
  if (inBrowser) {
    var o = window.performance.now();
    const i = e.__v_emitter;
    i &&
      n &&
      i.emit("message-evaluation", {
        type: "message-evaluation",
        value: a,
        time: o - n,
        groupId: "translate:" + t.key,
      }),
      r &&
        s &&
        mark &&
        measure &&
        (mark(s), measure("intlify message evaluation", r, s));
  }
  return a;
}
function parseTranslateArgs(...e) {
  var [e, t, a] = e;
  const n = {};
  if (!isString(e) && !isNumber(e) && !isMessageFunction(e))
    throw createCoreError(14);
  e = isNumber(e) ? String(e) : (isMessageFunction(e), e);
  return (
    isNumber(t)
      ? (n.plural = t)
      : isString(t)
      ? (n.default = t)
      : isPlainObject(t) && !isEmptyObject(t)
      ? (n.named = t)
      : isArray(t) && (n.list = t),
    isNumber(a)
      ? (n.plural = a)
      : isString(a)
      ? (n.default = a)
      : isPlainObject(a) && assign(n, a),
    [e, n]
  );
}
function getCompileOptions(r, t, s, o, e, i) {
  return {
    warnHtmlMessage: e,
    onError: e => {
      i && i(e);
      {
        var t = "Message compilation error: " + e.message,
          a =
            e.location &&
            generateCodeFrame(
              o,
              e.location.start.offset,
              e.location.end.offset
            );
        const n = r.__v_emitter;
        n &&
          n.emit("compile-error", {
            message: o,
            error: e.message,
            start: e.location && e.location.start.offset,
            end: e.location && e.location.end.offset,
            groupId: "translate:" + s,
          }),
          console.error(
            a
              ? t +
                  `
` +
                  a
              : t
          );
      }
    },
    onCacheKey: e => generateFormatCacheKey(t, s, e),
  };
}
function getMessageContextOptions(n, r, e, t) {
  var { modifiers: a, pluralRules: s } = n;
  const o = {
    locale: r,
    modifiers: a,
    pluralRules: s,
    messages: t => {
      var a = resolveValue(e, t);
      if (isString(a)) {
        let e = !1;
        t = compileMessageFormat(n, t, r, a, t, () => {
          e = !0;
        });
        return e ? NOOP_MESSAGE_FUNCTION : t;
      }
      return isMessageFunction(a) ? a : NOOP_MESSAGE_FUNCTION;
    },
  };
  return (
    n.processor && (o.processor = n.processor),
    t.list && (o.list = t.list),
    t.named && (o.named = t.named),
    isNumber(t.plural) && (o.pluralIndex = t.plural),
    o
  );
}
const intlDefined = "undefined" != typeof Intl,
  Availabilities = {
    dateTimeFormat: intlDefined && void 0 !== Intl.DateTimeFormat,
    numberFormat: intlDefined && void 0 !== Intl.NumberFormat,
  };
function datetime(t, ...e) {
  const {
      datetimeFormats: a,
      unresolving: n,
      fallbackLocale: r,
      onWarn: s,
    } = t,
    o = t["__datetimeFormatters"];
  if (!Availabilities.dateTimeFormat)
    return s(getWarnMessage$1(4)), MISSING_RESOLVE_VALUE;
  var [i, e, l, c] = parseDateTimeArgs(...e),
    u = (isBoolean(l.missingWarn) ? l : t).missingWarn,
    m = (isBoolean(l.fallbackWarn) ? l : t).fallbackWarn,
    g = !!l.part,
    p = (isString(l.locale) ? l : t).locale,
    f = getLocaleChain(t, r, p);
  if (!isString(i) || "" === i) return new Intl.DateTimeFormat(p).format(e);
  var d;
  let b,
    _ = null,
    v = p;
  var y,
    h = "datetime format";
  for (let e = 0; e < f.length; e++) {
    if (
      (p !== (b = y = f[e]) &&
        isTranslateFallbackWarn(m, i) &&
        s(getWarnMessage$1(5, { key: i, target: b })),
      p !== b)
    ) {
      const F = t.__v_emitter;
      F &&
        F.emit("fallback", {
          type: h,
          key: i,
          from: v,
          to: y,
          groupId: h + ":" + i,
        });
    }
    if (((d = a[b] || {}), (_ = d[i]), isPlainObject(_))) break;
    handleMissing(t, i, b, u, h), (v = y);
  }
  if (!isPlainObject(_) || !isString(b)) return n ? NOT_REOSLVED : i;
  let k = b + "__" + i,
    S = (isEmptyObject(c) || (k = k + "__" + JSON.stringify(c)), o.get(k));
  return (
    S || ((S = new Intl.DateTimeFormat(b, assign({}, _, c))), o.set(k, S)),
    g ? S.formatToParts(e) : S.format(e)
  );
}
function parseDateTimeArgs(...e) {
  const [t, a, n, r] = e;
  let s = {},
    o = {},
    i;
  if (isString(t)) {
    if (!/\d{4}-\d{2}-\d{2}(T.*)?/.test(t)) throw createCoreError(16);
    i = new Date(t);
    try {
      i.toISOString();
    } catch (e) {
      throw createCoreError(16);
    }
  } else if (isDate(t)) {
    if (isNaN(t.getTime())) throw createCoreError(15);
    i = t;
  } else {
    if (!isNumber(t)) throw createCoreError(14);
    i = t;
  }
  return (
    isString(a) ? (s.key = a) : isPlainObject(a) && (s = a),
    isString(n) ? (s.locale = n) : isPlainObject(n) && (o = n),
    isPlainObject(r) && (o = r),
    [s.key || "", i, s, o]
  );
}
function clearDateTimeFormat(e, t, a) {
  const n = e;
  for (const s in a) {
    var r = t + "__" + s;
    n.__datetimeFormatters.has(r) && n.__datetimeFormatters.delete(r);
  }
}
function number(t, ...e) {
  const { numberFormats: a, unresolving: n, fallbackLocale: r, onWarn: s } = t,
    o = t["__numberFormatters"];
  if (!Availabilities.numberFormat)
    return s(getWarnMessage$1(2)), MISSING_RESOLVE_VALUE;
  var [i, e, l, c] = parseNumberArgs(...e),
    u = (isBoolean(l.missingWarn) ? l : t).missingWarn,
    m = (isBoolean(l.fallbackWarn) ? l : t).fallbackWarn,
    g = !!l.part,
    p = (isString(l.locale) ? l : t).locale,
    f = getLocaleChain(t, r, p);
  if (!isString(i) || "" === i) return new Intl.NumberFormat(p).format(e);
  var d;
  let b,
    _ = null,
    v = p;
  var y,
    h = "number format";
  for (let e = 0; e < f.length; e++) {
    if (
      (p !== (b = y = f[e]) &&
        isTranslateFallbackWarn(m, i) &&
        s(getWarnMessage$1(3, { key: i, target: b })),
      p !== b)
    ) {
      const F = t.__v_emitter;
      F &&
        F.emit("fallback", {
          type: h,
          key: i,
          from: v,
          to: y,
          groupId: h + ":" + i,
        });
    }
    if (((d = a[b] || {}), (_ = d[i]), isPlainObject(_))) break;
    handleMissing(t, i, b, u, h), (v = y);
  }
  if (!isPlainObject(_) || !isString(b)) return n ? NOT_REOSLVED : i;
  let k = b + "__" + i,
    S = (isEmptyObject(c) || (k = k + "__" + JSON.stringify(c)), o.get(k));
  return (
    S || ((S = new Intl.NumberFormat(b, assign({}, _, c))), o.set(k, S)),
    g ? S.formatToParts(e) : S.format(e)
  );
}
function parseNumberArgs(...e) {
  var [e, t, a, n] = e;
  let r = {},
    s = {};
  if (!isNumber(e)) throw createCoreError(14);
  return (
    isString(t) ? (r.key = t) : isPlainObject(t) && (r = t),
    isString(a) ? (r.locale = a) : isPlainObject(a) && (s = a),
    isPlainObject(n) && (s = n),
    [r.key || "", e, r, s]
  );
}
function clearNumberFormat(e, t, a) {
  const n = e;
  for (const s in a) {
    var r = t + "__" + s;
    n.__numberFormatters.has(r) && n.__numberFormatters.delete(r);
  }
}
const VERSION = "9.1.10";
function initDev() {
  console.info(
    "You are running a development build of vue-i18n.\nMake sure to use the production build (*.prod.js) when deploying for production."
  );
}
const warnMessages = {
  [6]: "Fall back to {type} '{key}' with root locale.",
  7: "Not supported 'preserve'.",
  8: "Not supported 'formatter'.",
  9: "Not supported 'preserveDirectiveContent'.",
  10: "Not supported 'getChoiceIndex'.",
  11: "Component name legacy compatible: '{name}' -> 'i18n'",
  12: "Not found parent scope. use the global scope.",
};
function getWarnMessage(e, ...t) {
  return format(warnMessages[e], ...t);
}
function createI18nError(e, ...t) {
  return createCompileError(e, null, { messages: errorMessages, args: t });
}
const errorMessages = {
    [14]: "Unexpected return type in composer",
    15: "Invalid argument",
    16: "Must be called at the top of a `setup` function",
    17: "Need to install with `app.use` function",
    22: "Unexpected error",
    18: "Not available in legacy mode",
    19: "Required in value: {0}",
    20: "Invalid value",
    21: "Cannot setup vue-devtools plugin",
  },
  DEVTOOLS_META = "__INTLIFY_META__",
  TransrateVNodeSymbol = makeSymbol("__transrateVNode"),
  DatetimePartsSymbol = makeSymbol("__datetimeParts"),
  NumberPartsSymbol = makeSymbol("__numberParts"),
  EnableEmitter = makeSymbol("__enableEmitter"),
  DisableEmitter = makeSymbol("__disableEmitter"),
  SetPluralRulesSymbol = makeSymbol("__setPluralRules"),
  InejctWithOption = makeSymbol("__injectWithOption");
let composerID = 0;
function defineCoreMissingHandler(r) {
  return (e, t, a, n) => r(t, a, getCurrentInstance() || void 0, n);
}
function getLocaleMessages(e, t) {
  const { messages: a, __i18n: n } = t,
    r = isPlainObject(a) ? a : isArray(n) ? {} : { [e]: {} };
  if (
    (isArray(n) &&
      n.forEach(({ locale: e, resource: t }) => {
        e ? ((r[e] = r[e] || {}), deepCopy(t, r[e])) : deepCopy(t, r);
      }),
    t.flatJson)
  )
    for (const s in r) hasOwn(r, s) && handleFlatJson(r[s]);
  return r;
}
const isNotObjectOrIsArray = e => !isObject(e) || isArray(e);
function deepCopy(e, t) {
  if (isNotObjectOrIsArray(e) || isNotObjectOrIsArray(t))
    throw createI18nError(20);
  for (const a in e)
    hasOwn(e, a) &&
      (isNotObjectOrIsArray(e[a]) || isNotObjectOrIsArray(t[a])
        ? (t[a] = e[a])
        : deepCopy(e[a], t[a]));
}
const getMetaInfo = () => {
  var e = getCurrentInstance();
  return e && e.type[DEVTOOLS_META]
    ? { [DEVTOOLS_META]: e.type[DEVTOOLS_META] }
    : null;
};
function createComposer(e = {}) {
  const l = e["__root"],
    t = void 0 === l;
  let a = !isBoolean(e.inheritLocale) || e.inheritLocale;
  const c = ref(
      l && a ? l.locale.value : isString(e.locale) ? e.locale : "en-US"
    ),
    u = ref(
      l && a
        ? l.fallbackLocale.value
        : isString(e.fallbackLocale) ||
          isArray(e.fallbackLocale) ||
          isPlainObject(e.fallbackLocale) ||
          !1 === e.fallbackLocale
        ? e.fallbackLocale
        : c.value
    ),
    m = ref(getLocaleMessages(c.value, e)),
    g = ref(
      isPlainObject(e.datetimeFormats) ? e.datetimeFormats : { [c.value]: {} }
    ),
    p = ref(
      isPlainObject(e.numberFormats) ? e.numberFormats : { [c.value]: {} }
    );
  let f = l
      ? l.missingWarn
      : (!isBoolean(e.missingWarn) && !isRegExp(e.missingWarn)) ||
        e.missingWarn,
    d = l
      ? l.fallbackWarn
      : (!isBoolean(e.fallbackWarn) && !isRegExp(e.fallbackWarn)) ||
        e.fallbackWarn,
    b = l ? l.fallbackRoot : !isBoolean(e.fallbackRoot) || e.fallbackRoot,
    n = !!e.fallbackFormat,
    r = isFunction(e.missing) ? e.missing : null,
    s = isFunction(e.missing) ? defineCoreMissingHandler(e.missing) : null,
    o = isFunction(e.postTranslation) ? e.postTranslation : null,
    i = !isBoolean(e.warnHtmlMessage) || e.warnHtmlMessage,
    _ = !!e.escapeParameter;
  const v = l ? l.modifiers : isPlainObject(e.modifiers) ? e.modifiers : {};
  let y = e.pluralRules || (l && l.pluralRules),
    h;
  updateFallbackLocale(
    (h = createCoreContext({
      version: VERSION,
      locale: c.value,
      fallbackLocale: u.value,
      messages: m.value,
      datetimeFormats: g.value,
      numberFormats: p.value,
      modifiers: v,
      pluralRules: y,
      missing: null === s ? void 0 : s,
      missingWarn: f,
      fallbackWarn: d,
      fallbackFormat: n,
      unresolving: !0,
      postTranslation: null === o ? void 0 : o,
      warnHtmlMessage: i,
      escapeParameter: _,
      __datetimeFormatters: isPlainObject(h) ? h.__datetimeFormatters : void 0,
      __numberFormatters: isPlainObject(h) ? h.__numberFormatters : void 0,
      __v_emitter: isPlainObject(h) ? h.__v_emitter : void 0,
      __meta: { framework: "vue" },
    })),
    c.value,
    u.value
  );
  var k = computed({
      get: () => c.value,
      set: e => {
        (c.value = e), (h.locale = c.value);
      },
    }),
    S = computed({
      get: () => u.value,
      set: e => {
        (u.value = e),
          (h.fallbackLocale = u.value),
          updateFallbackLocale(h, c.value, e);
      },
    }),
    F = computed(() => m.value),
    E = computed(() => g.value),
    O = computed(() => p.value);
  function T(e, t, a, n, r, s) {
    c.value, u.value, m.value, g.value, p.value;
    let o;
    try {
      setAdditionalMeta(getMetaInfo()), (o = e(h));
    } finally {
      setAdditionalMeta(null);
    }
    if (isNumber(o) && o === NOT_REOSLVED) {
      var [e, t] = t();
      if (
        l &&
        isString(e) &&
        ((t = t), "translate" !== a || !1 == !!t.resolvedMessage)
      ) {
        b &&
          (isTranslateFallbackWarn(d, e) || isTranslateMissingWarn(f, e)) &&
          warn(getWarnMessage(6, { key: e, type: a }));
        {
          const i = h["__v_emitter"];
          i &&
            b &&
            i.emit("fallback", {
              type: a,
              key: e,
              to: "global",
              groupId: a + ":" + e,
            });
        }
      }
      return l && b ? n(l) : r(e);
    }
    if (s(o)) return o;
    throw createI18nError(14);
  }
  function M(...t) {
    return T(
      e => translate(e, ...t),
      () => parseTranslateArgs(...t),
      "translate",
      e => e.t(...t),
      e => e,
      e => isString(e)
    );
  }
  const I = {
    normalize: function (e) {
      return e.map(e => (isString(e) ? createVNode(Text, null, e, 0) : e));
    },
    interpolate: e => e,
    type: "vnode",
  };
  function L(e) {
    return m.value[e] || {};
  }
  composerID++,
    l &&
      (watch(l.locale, e => {
        a &&
          ((c.value = e),
          (h.locale = e),
          updateFallbackLocale(h, c.value, u.value));
      }),
      watch(l.fallbackLocale, e => {
        a &&
          ((u.value = e),
          (h.fallbackLocale = e),
          updateFallbackLocale(h, c.value, u.value));
      }));
  const N = {
    id: composerID,
    locale: k,
    fallbackLocale: S,
    get inheritLocale() {
      return a;
    },
    set inheritLocale(e) {
      (a = e) &&
        l &&
        ((c.value = l.locale.value),
        (u.value = l.fallbackLocale.value),
        updateFallbackLocale(h, c.value, u.value));
    },
    get availableLocales() {
      return Object.keys(m.value).sort();
    },
    messages: F,
    datetimeFormats: E,
    numberFormats: O,
    get modifiers() {
      return v;
    },
    get pluralRules() {
      return y || {};
    },
    get isGlobal() {
      return t;
    },
    get missingWarn() {
      return f;
    },
    set missingWarn(e) {
      (f = e), (h.missingWarn = f);
    },
    get fallbackWarn() {
      return d;
    },
    set fallbackWarn(e) {
      (d = e), (h.fallbackWarn = d);
    },
    get fallbackRoot() {
      return b;
    },
    set fallbackRoot(e) {
      b = e;
    },
    get fallbackFormat() {
      return n;
    },
    set fallbackFormat(e) {
      (n = e), (h.fallbackFormat = n);
    },
    get warnHtmlMessage() {
      return i;
    },
    set warnHtmlMessage(e) {
      (i = e), (h.warnHtmlMessage = e);
    },
    get escapeParameter() {
      return _;
    },
    set escapeParameter(e) {
      (_ = e), (h.escapeParameter = e);
    },
    t: M,
    rt: function (...e) {
      var [e, t, a] = e;
      if (a && !isObject(a)) throw createI18nError(15);
      return M(e, t, assign({ resolvedMessage: !0 }, a || {}));
    },
    d: function (...t) {
      return T(
        e => datetime(e, ...t),
        () => parseDateTimeArgs(...t),
        "datetime format",
        e => e.d(...t),
        () => MISSING_RESOLVE_VALUE,
        e => isString(e)
      );
    },
    n: function (...t) {
      return T(
        e => number(e, ...t),
        () => parseNumberArgs(...t),
        "number format",
        e => e.n(...t),
        () => MISSING_RESOLVE_VALUE,
        e => isString(e)
      );
    },
    te: function (e, t) {
      return null !== resolveValue(L(isString(t) ? t : c.value), e);
    },
    tm: function (e) {
      var t = (function (t) {
        let a = null;
        var n = getLocaleChain(h, u.value, c.value);
        for (let e = 0; e < n.length; e++) {
          var r = resolveValue(m.value[n[e]] || {}, t);
          if (null != r) {
            a = r;
            break;
          }
        }
        return a;
      })(e);
      return null != t ? t : (l && l.tm(e)) || {};
    },
    getLocaleMessage: L,
    setLocaleMessage: function (e, t) {
      (m.value[e] = t), (h.messages = m.value);
    },
    mergeLocaleMessage: function (e, t) {
      (m.value[e] = m.value[e] || {}),
        deepCopy(t, m.value[e]),
        (h.messages = m.value);
    },
    getDateTimeFormat: function (e) {
      return g.value[e] || {};
    },
    setDateTimeFormat: function (e, t) {
      (g.value[e] = t),
        (h.datetimeFormats = g.value),
        clearDateTimeFormat(h, e, t);
    },
    mergeDateTimeFormat: function (e, t) {
      (g.value[e] = assign(g.value[e] || {}, t)),
        (h.datetimeFormats = g.value),
        clearDateTimeFormat(h, e, t);
    },
    getNumberFormat: function (e) {
      return p.value[e] || {};
    },
    setNumberFormat: function (e, t) {
      (p.value[e] = t), (h.numberFormats = p.value), clearNumberFormat(h, e, t);
    },
    mergeNumberFormat: function (e, t) {
      (p.value[e] = assign(p.value[e] || {}, t)),
        (h.numberFormats = p.value),
        clearNumberFormat(h, e, t);
    },
    getPostTranslationHandler: function () {
      return isFunction(o) ? o : null;
    },
    setPostTranslationHandler: function (e) {
      (o = e), (h.postTranslation = e);
    },
    getMissingHandler: function () {
      return r;
    },
    setMissingHandler: function (e) {
      null !== e && (s = defineCoreMissingHandler(e)), (r = e), (h.missing = s);
    },
    [TransrateVNodeSymbol]: function (...n) {
      return T(
        e => {
          let t;
          const a = e;
          try {
            (a.processor = I), (t = translate(a, ...n));
          } finally {
            a.processor = null;
          }
          return t;
        },
        () => parseTranslateArgs(...n),
        "translate",
        e => e[TransrateVNodeSymbol](...n),
        e => [createVNode(Text, null, e, 0)],
        e => isArray(e)
      );
    },
    [NumberPartsSymbol]: function (...t) {
      return T(
        e => number(e, ...t),
        () => parseNumberArgs(...t),
        "number format",
        e => e[NumberPartsSymbol](...t),
        () => [],
        e => isString(e) || isArray(e)
      );
    },
    [DatetimePartsSymbol]: function (...t) {
      return T(
        e => datetime(e, ...t),
        () => parseDateTimeArgs(...t),
        "datetime format",
        e => e[DatetimePartsSymbol](...t),
        () => [],
        e => isString(e) || isArray(e)
      );
    },
    [SetPluralRulesSymbol]: function (e) {
      (y = e), (h.pluralRules = y);
    },
    [InejctWithOption]: e.__injectWithOption,
  };
  return (
    (N[EnableEmitter] = e => {
      h.__v_emitter = e;
    }),
    (N[DisableEmitter] = () => {
      h.__v_emitter = void 0;
    }),
    N
  );
}
function convertComposerOptions(e) {
  var t = isString(e.locale) ? e.locale : "en-US",
    a =
      isString(e.fallbackLocale) ||
      isArray(e.fallbackLocale) ||
      isPlainObject(e.fallbackLocale) ||
      !1 === e.fallbackLocale
        ? e.fallbackLocale
        : t,
    n = isFunction(e.missing) ? e.missing : void 0,
    r =
      (!isBoolean(e.silentTranslationWarn) &&
        !isRegExp(e.silentTranslationWarn)) ||
      !e.silentTranslationWarn,
    s =
      (!isBoolean(e.silentFallbackWarn) && !isRegExp(e.silentFallbackWarn)) ||
      !e.silentFallbackWarn,
    o = !isBoolean(e.fallbackRoot) || e.fallbackRoot,
    i = !!e.formatFallbackMessages,
    l = isPlainObject(e.modifiers) ? e.modifiers : {},
    c = e.pluralizationRules,
    u = isFunction(e.postTranslation) ? e.postTranslation : void 0,
    m = !isString(e.warnHtmlInMessage) || "off" !== e.warnHtmlInMessage,
    g = !!e.escapeParameterHtml,
    p = !isBoolean(e.sync) || e.sync;
  e.formatter && warn(getWarnMessage(8)),
    e.preserveDirectiveContent && warn(getWarnMessage(9));
  let f = e.messages;
  if (isPlainObject(e.sharedMessages)) {
    const h = e.sharedMessages,
      k = Object.keys(h);
    f = k.reduce((e, t) => {
      var a = e[t] || (e[t] = {});
      return assign(a, h[t]), e;
    }, f || {});
  }
  var { __i18n: d, __root: b, __injectWithOption: _ } = e,
    v = e.datetimeFormats,
    y = e.numberFormats,
    e = e.flatJson;
  return {
    locale: t,
    fallbackLocale: a,
    messages: f,
    flatJson: e,
    datetimeFormats: v,
    numberFormats: y,
    missing: n,
    missingWarn: r,
    fallbackWarn: s,
    fallbackRoot: o,
    fallbackFormat: i,
    modifiers: l,
    pluralRules: c,
    postTranslation: u,
    warnHtmlMessage: m,
    escapeParameter: g,
    inheritLocale: p,
    __i18n: d,
    __root: b,
    __injectWithOption: _,
  };
}
function createVueI18n(a = {}) {
  const o = createComposer(convertComposerOptions(a)),
    n = {
      id: o.id,
      get locale() {
        return o.locale.value;
      },
      set locale(e) {
        o.locale.value = e;
      },
      get fallbackLocale() {
        return o.fallbackLocale.value;
      },
      set fallbackLocale(e) {
        o.fallbackLocale.value = e;
      },
      get messages() {
        return o.messages.value;
      },
      get datetimeFormats() {
        return o.datetimeFormats.value;
      },
      get numberFormats() {
        return o.numberFormats.value;
      },
      get availableLocales() {
        return o.availableLocales;
      },
      get formatter() {
        return (
          warn(getWarnMessage(8)),
          {
            interpolate() {
              return [];
            },
          }
        );
      },
      set formatter(e) {
        warn(getWarnMessage(8));
      },
      get missing() {
        return o.getMissingHandler();
      },
      set missing(e) {
        o.setMissingHandler(e);
      },
      get silentTranslationWarn() {
        return isBoolean(o.missingWarn) ? !o.missingWarn : o.missingWarn;
      },
      set silentTranslationWarn(e) {
        o.missingWarn = isBoolean(e) ? !e : e;
      },
      get silentFallbackWarn() {
        return isBoolean(o.fallbackWarn) ? !o.fallbackWarn : o.fallbackWarn;
      },
      set silentFallbackWarn(e) {
        o.fallbackWarn = isBoolean(e) ? !e : e;
      },
      get modifiers() {
        return o.modifiers;
      },
      get formatFallbackMessages() {
        return o.fallbackFormat;
      },
      set formatFallbackMessages(e) {
        o.fallbackFormat = e;
      },
      get postTranslation() {
        return o.getPostTranslationHandler();
      },
      set postTranslation(e) {
        o.setPostTranslationHandler(e);
      },
      get sync() {
        return o.inheritLocale;
      },
      set sync(e) {
        o.inheritLocale = e;
      },
      get warnHtmlInMessage() {
        return o.warnHtmlMessage ? "warn" : "off";
      },
      set warnHtmlInMessage(e) {
        o.warnHtmlMessage = "off" !== e;
      },
      get escapeParameterHtml() {
        return o.escapeParameter;
      },
      set escapeParameterHtml(e) {
        o.escapeParameter = e;
      },
      get preserveDirectiveContent() {
        return warn(getWarnMessage(9)), !0;
      },
      set preserveDirectiveContent(e) {
        warn(getWarnMessage(9));
      },
      get pluralizationRules() {
        return o.pluralRules || {};
      },
      __composer: o,
      t(...e) {
        var [e, t, a] = e;
        const n = {};
        let r = null,
          s = null;
        if (!isString(e)) throw createI18nError(15);
        return (
          isString(t)
            ? (n.locale = t)
            : isArray(t)
            ? (r = t)
            : isPlainObject(t) && (s = t),
          isArray(a) ? (r = a) : isPlainObject(a) && (s = a),
          o.t(e, r || s || {}, n)
        );
      },
      rt(...e) {
        return o.rt(...e);
      },
      tc(...e) {
        var [e, t, a] = e;
        const n = { plural: 1 };
        let r = null,
          s = null;
        if (!isString(e)) throw createI18nError(15);
        return (
          isString(t)
            ? (n.locale = t)
            : isNumber(t)
            ? (n.plural = t)
            : isArray(t)
            ? (r = t)
            : isPlainObject(t) && (s = t),
          isString(a)
            ? (n.locale = a)
            : isArray(a)
            ? (r = a)
            : isPlainObject(a) && (s = a),
          o.t(e, r || s || {}, n)
        );
      },
      te(e, t) {
        return o.te(e, t);
      },
      tm(e) {
        return o.tm(e);
      },
      getLocaleMessage(e) {
        return o.getLocaleMessage(e);
      },
      setLocaleMessage(e, t) {
        o.setLocaleMessage(e, t);
      },
      mergeLocaleMessage(e, t) {
        o.mergeLocaleMessage(e, t);
      },
      d(...e) {
        return o.d(...e);
      },
      getDateTimeFormat(e) {
        return o.getDateTimeFormat(e);
      },
      setDateTimeFormat(e, t) {
        o.setDateTimeFormat(e, t);
      },
      mergeDateTimeFormat(e, t) {
        o.mergeDateTimeFormat(e, t);
      },
      n(...e) {
        return o.n(...e);
      },
      getNumberFormat(e) {
        return o.getNumberFormat(e);
      },
      setNumberFormat(e, t) {
        o.setNumberFormat(e, t);
      },
      mergeNumberFormat(e, t) {
        o.mergeNumberFormat(e, t);
      },
      getChoiceIndex(e, t) {
        return warn(getWarnMessage(10)), -1;
      },
      __onComponentInstanceCreated(e) {
        const t = a["componentInstanceCreatedListener"];
        t && t(e, n);
      },
      __enableEmitter: e => {
        const t = o;
        t[EnableEmitter] && t[EnableEmitter](e);
      },
      __disableEmitter: () => {
        const e = o;
        e[DisableEmitter] && e[DisableEmitter]();
      },
    };
  return n;
}
const baseFormatProps = {
    tag: { type: [String, Object] },
    locale: { type: String },
    scope: {
      type: String,
      validator: e => "parent" === e || "global" === e,
      default: "parent",
    },
    i18n: { type: Object },
  },
  Translation = {
    name: "i18n-t",
    props: assign(
      {
        keypath: { type: String, required: !0 },
        plural: {
          type: [Number, String],
          validator: e => isNumber(e) || !isNaN(e),
        },
      },
      baseFormatProps
    ),
    setup(n, r) {
      const { slots: e, attrs: s } = r,
        o = n.i18n || useI18n({ useScope: n.scope, __useComponent: !0 }),
        i = Object.keys(e).filter(e => "_" !== e);
      return () => {
        const e = {};
        n.locale && (e.locale = n.locale),
          void 0 !== n.plural &&
            (e.plural = isString(n.plural) ? +n.plural : n.plural);
        var t = getInterpolateArg(r, i),
          t = o[TransrateVNodeSymbol](n.keypath, t, e),
          a = assign({}, s);
        return isString(n.tag) || isObject(n.tag)
          ? h(n.tag, a, t)
          : h(Fragment, a, t);
      };
    },
  };
function getInterpolateArg({ slots: n }, e) {
  return 1 === e.length && "default" === e[0]
    ? n.default
      ? n.default()
      : []
    : e.reduce((e, t) => {
        const a = n[t];
        return a && (e[t] = a()), e;
      }, {});
}
function renderFormatter(s, e, o, i) {
  const { slots: l, attrs: c } = e;
  return () => {
    const e = { part: !0 };
    let t = {};
    s.locale && (e.locale = s.locale),
      isString(s.format)
        ? (e.key = s.format)
        : isObject(s.format) &&
          (isString(s.format.key) && (e.key = s.format.key),
          (t = Object.keys(s.format).reduce(
            (e, t) => (o.includes(t) ? assign({}, e, { [t]: s.format[t] }) : e),
            {}
          )));
    const n = i(s.value, e, t);
    let a = [e.key];
    isArray(n)
      ? (a = n.map((e, t) => {
          const a = l[e.type];
          return a ? a({ [e.type]: e.value, index: t, parts: n }) : [e.value];
        }))
      : isString(n) && (a = [n]);
    var r = assign({}, c);
    return isString(s.tag) || isObject(s.tag)
      ? h(s.tag, r, a)
      : h(Fragment, r, a);
  };
}
const NUMBER_FORMAT_KEYS = [
    "localeMatcher",
    "style",
    "unit",
    "unitDisplay",
    "currency",
    "currencyDisplay",
    "useGrouping",
    "numberingSystem",
    "minimumIntegerDigits",
    "minimumFractionDigits",
    "maximumFractionDigits",
    "minimumSignificantDigits",
    "maximumSignificantDigits",
    "notation",
    "formatMatcher",
  ],
  NumberFormat = {
    name: "i18n-n",
    props: assign(
      {
        value: { type: Number, required: !0 },
        format: { type: [String, Object] },
      },
      baseFormatProps
    ),
    setup(e, t) {
      const a = e.i18n || useI18n({ useScope: "parent", __useComponent: !0 });
      return renderFormatter(e, t, NUMBER_FORMAT_KEYS, (...e) =>
        a[NumberPartsSymbol](...e)
      );
    },
  },
  DATETIME_FORMAT_KEYS = [
    "dateStyle",
    "timeStyle",
    "fractionalSecondDigits",
    "calendar",
    "dayPeriod",
    "numberingSystem",
    "localeMatcher",
    "timeZone",
    "hour12",
    "hourCycle",
    "formatMatcher",
    "weekday",
    "era",
    "year",
    "month",
    "day",
    "hour",
    "minute",
    "second",
    "timeZoneName",
  ],
  DatetimeFormat = {
    name: "i18n-d",
    props: assign(
      {
        value: { type: [Number, Date], required: !0 },
        format: { type: [String, Object] },
      },
      baseFormatProps
    ),
    setup(e, t) {
      const a = e.i18n || useI18n({ useScope: "parent", __useComponent: !0 });
      return renderFormatter(e, t, DATETIME_FORMAT_KEYS, (...e) =>
        a[DatetimePartsSymbol](...e)
      );
    },
  };
function getComposer$2(e, t) {
  const a = e;
  return "composition" === e.mode
    ? a.__getInstance(t) || e.global
    : (null != (t = a.__getInstance(t)) ? t : e.global).__composer;
}
function vTDirective(s) {
  var e = (e, { instance: t, value: a, modifiers: n }) => {
    if (!t || !t.$) throw createI18nError(22);
    const r = getComposer$2(s, t.$);
    n.preserve && warn(getWarnMessage(7));
    t = parseValue(a);
    e.textContent = r.t(...makeParams(t));
  };
  return { beforeMount: e, beforeUpdate: e };
}
function parseValue(e) {
  if (isString(e)) return { path: e };
  if (isPlainObject(e)) {
    if ("path" in e) return e;
    throw createI18nError(19, "path");
  }
  throw createI18nError(20);
}
function makeParams(e) {
  var { path: e, locale: t, args: a, choice: n, plural: r } = e;
  const s = {};
  a = a || {};
  return (
    isString(t) && (s.locale = t),
    isNumber(n) && (s.plural = n),
    isNumber(r) && (s.plural = r),
    [e, a, s]
  );
}
function apply(e, t, ...a) {
  var a = isPlainObject(a[0]) ? a[0] : {},
    n = !!a.useI18nComponentName,
    a = !isBoolean(a.globalInstall) || a.globalInstall;
  a && n && warn(getWarnMessage(11, { name: Translation.name })),
    a &&
      (e.component(n ? "i18n" : Translation.name, Translation),
      e.component(NumberFormat.name, NumberFormat),
      e.component(DatetimeFormat.name, DatetimeFormat)),
    e.directive("t", vTDirective(t));
}
var global$1 =
  "undefined" != typeof global
    ? global
    : "undefined" != typeof self
    ? self
    : "undefined" != typeof window
    ? window
    : {};
function getDevtoolsGlobalHook() {
  return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function getTarget() {
  return "undefined" != typeof navigator
    ? window
    : void 0 !== global$1
    ? global$1
    : {};
}
const HOOK_SETUP = "devtools-plugin:setup";
function setupDevtoolsPlugin(e, t) {
  const a = getDevtoolsGlobalHook();
  if (a) a.emit(HOOK_SETUP, e, t);
  else {
    const n = getTarget(),
      r = (n.__VUE_DEVTOOLS_PLUGINS__ = n.__VUE_DEVTOOLS_PLUGINS__ || []);
    r.push({ pluginDescriptor: e, setupFn: t });
  }
}
const VueDevToolsLabels = {
    "vue-devtools-plugin-vue-i18n": "Vue I18n devtools",
    "vue-i18n-resource-inspector": "I18n Resources",
    "vue-i18n-timeline": "Vue I18n",
  },
  VueDevToolsPlaceholders = {
    "vue-i18n-resource-inspector": "Search for scopes ...",
  },
  VueDevToolsTimelineColors = { "vue-i18n-timeline": 16764185 },
  VUE_I18N_COMPONENT_TYPES = "vue-i18n: composer properties";
let devtoolsApi;
async function enableDevTools(n, r) {
  return new Promise((t, a) => {
    try {
      setupDevtoolsPlugin(
        {
          id: "vue-devtools-plugin-vue-i18n",
          label: VueDevToolsLabels["vue-devtools-plugin-vue-i18n"],
          packageName: "vue-i18n",
          homepage: "https://vue-i18n.intlify.dev",
          logo: "https://vue-i18n.intlify.dev/vue-i18n-devtools-logo.png",
          componentStateTypes: [VUE_I18N_COMPONENT_TYPES],
          app: n,
        },
        e => {
          (devtoolsApi = e).on.visitComponentTree(
            ({ componentInstance: e, treeNode: t }) => {
              updateComponentTreeTags(e, t, r);
            }
          ),
            e.on.inspectComponent(
              ({ componentInstance: e, instanceData: t }) => {
                e.vnode.el.__VUE_I18N__ &&
                  t &&
                  ("legacy" !== r.mode ||
                    e.vnode.el.__VUE_I18N__ !== r.global.__composer) &&
                  inspectComposer(t, e.vnode.el.__VUE_I18N__);
              }
            ),
            e.addInspector({
              id: "vue-i18n-resource-inspector",
              label: VueDevToolsLabels["vue-i18n-resource-inspector"],
              icon: "language",
              treeFilterPlaceholder:
                VueDevToolsPlaceholders["vue-i18n-resource-inspector"],
            }),
            e.on.getInspectorTree(e => {
              e.app === n &&
                "vue-i18n-resource-inspector" === e.inspectorId &&
                registerScope(e, r);
            }),
            e.on.getInspectorState(e => {
              e.app === n &&
                "vue-i18n-resource-inspector" === e.inspectorId &&
                inspectScope(e, r);
            }),
            e.on.editInspectorState(e => {
              e.app === n &&
                "vue-i18n-resource-inspector" === e.inspectorId &&
                editScope(e, r);
            }),
            e.addTimelineLayer({
              id: "vue-i18n-timeline",
              label: VueDevToolsLabels["vue-i18n-timeline"],
              color: VueDevToolsTimelineColors["vue-i18n-timeline"],
            }),
            t(!0);
        }
      );
    } catch (e) {
      console.error(e), a(!1);
    }
  });
}
function updateComponentTreeTags(e, t, a) {
  var a = "composition" === a.mode ? a.global : a.global.__composer;
  e &&
    e.vnode.el.__VUE_I18N__ &&
    e.vnode.el.__VUE_I18N__ !== a &&
    ((a = e.type.name || e.type.displayName || e.type.__file),
    t.tags.push({
      label: `i18n (${a} Scope)`,
      textColor: 0,
      backgroundColor: 16764185,
    }));
}
function inspectComposer(e, t) {
  var a = VUE_I18N_COMPONENT_TYPES;
  e.state.push({ type: a, key: "locale", editable: !0, value: t.locale.value }),
    e.state.push({
      type: a,
      key: "availableLocales",
      editable: !1,
      value: t.availableLocales,
    }),
    e.state.push({
      type: a,
      key: "fallbackLocale",
      editable: !0,
      value: t.fallbackLocale.value,
    }),
    e.state.push({
      type: a,
      key: "inheritLocale",
      editable: !0,
      value: t.inheritLocale,
    }),
    e.state.push({
      type: a,
      key: "messages",
      editable: !1,
      value: getLocaleMessageValue(t.messages.value),
    }),
    e.state.push({
      type: a,
      key: "datetimeFormats",
      editable: !1,
      value: t.datetimeFormats.value,
    }),
    e.state.push({
      type: a,
      key: "numberFormats",
      editable: !1,
      value: t.numberFormats.value,
    });
}
function getLocaleMessageValue(a) {
  const n = {};
  return (
    Object.keys(a).forEach(e => {
      var t = a[e];
      isFunction(t) && "source" in t
        ? (n[e] = getMessageFunctionDetails(t))
        : isObject(t)
        ? (n[e] = getLocaleMessageValue(t))
        : (n[e] = t);
    }),
    n
  );
}
const ESC = { "<": "&lt;", ">": "&gt;", '"': "&quot;", "&": "&amp;" };
function escape(e) {
  return e.replace(/[<>"&]/g, escapeChar);
}
function escapeChar(e) {
  return ESC[e] || e;
}
function getMessageFunctionDetails(e) {
  return {
    _custom: {
      type: "function",
      display:
        "<span></span> " + (e.source ? `("${escape(e.source)}")` : "(?)"),
    },
  };
}
function registerScope(e, t) {
  e.rootNodes.push({ id: "global", label: "Global Scope" });
  var a,
    n,
    r,
    s = "composition" === t.mode ? t.global : t.global.__composer;
  for ([a, n] of t.__instances) {
    const o = "composition" === t.mode ? n : n.__composer;
    s !== o &&
      ((r = a.type.name || a.type.displayName || a.type.__file),
      e.rootNodes.push({ id: o.id.toString(), label: r + " Scope" }));
  }
}
function getComposer$1(t, e) {
  var a;
  return "global" === t
    ? "composition" === e.mode
      ? e.global
      : e.global.__composer
    : (a = Array.from(e.__instances.values()).find(e => e.id.toString() === t))
    ? "composition" === e.mode
      ? a
      : a.__composer
    : null;
}
function inspectScope(e, t) {
  t = getComposer$1(e.nodeId, t);
  t && (e.state = makeScopeInspectState(t));
}
function makeScopeInspectState(e) {
  const t = {};
  var a = "Locale related info",
    n = [
      { type: a, key: "locale", editable: !0, value: e.locale.value },
      {
        type: a,
        key: "fallbackLocale",
        editable: !0,
        value: e.fallbackLocale.value,
      },
      {
        type: a,
        key: "availableLocales",
        editable: !1,
        value: e.availableLocales,
      },
      { type: a, key: "inheritLocale", editable: !0, value: e.inheritLocale },
    ],
    a = ((t[a] = n), "Locale messages info"),
    n = [
      {
        type: a,
        key: "messages",
        editable: !1,
        value: getLocaleMessageValue(e.messages.value),
      },
    ],
    a = ((t[a] = n), "Datetime formats info"),
    n = [
      {
        type: a,
        key: "datetimeFormats",
        editable: !1,
        value: e.datetimeFormats.value,
      },
    ],
    a = ((t[a] = n), "Datetime formats info"),
    n = [
      {
        type: a,
        key: "numberFormats",
        editable: !1,
        value: e.numberFormats.value,
      },
    ];
  return (t[a] = n), t;
}
function addTimelineEvent(t, a) {
  if (devtoolsApi) {
    let e;
    a && "groupId" in a && ((e = a.groupId), delete a.groupId),
      devtoolsApi.addTimelineEvent({
        layerId: "vue-i18n-timeline",
        event: {
          title: t,
          groupId: e,
          time: Date.now(),
          meta: {},
          data: a || {},
          logType:
            "compile-error" === t
              ? "error"
              : "fallback" === t || "missing" === t
              ? "warning"
              : "default",
        },
      });
  }
}
function editScope(e, t) {
  const a = getComposer$1(e.nodeId, t);
  a &&
    (([t] = e.path),
    "locale" === t && isString(e.state.value)
      ? (a.locale.value = e.state.value)
      : "fallbackLocale" === t &&
        (isString(e.state.value) ||
          isArray(e.state.value) ||
          isObject(e.state.value))
      ? (a.fallbackLocale.value = e.state.value)
      : "inheritLocale" === t &&
        isBoolean(e.state.value) &&
        (a.inheritLocale = e.state.value));
}
function defineMixin(n, r, s) {
  return {
    beforeCreate() {
      var e = getCurrentInstance();
      if (!e) throw createI18nError(22);
      var t = this.$options;
      if (t.i18n) {
        const a = t.i18n;
        t.__i18n && (a.__i18n = t.__i18n),
          (a.__root = r),
          this === this.$root
            ? (this.$i18n = mergeToRoot(n, a))
            : ((a.__injectWithOption = !0), (this.$i18n = createVueI18n(a)));
      } else
        t.__i18n
          ? this === this.$root
            ? (this.$i18n = mergeToRoot(n, t))
            : (this.$i18n = createVueI18n({
                __i18n: t.__i18n,
                __injectWithOption: !0,
                __root: r,
              }))
          : (this.$i18n = n);
      n.__onComponentInstanceCreated(this.$i18n),
        s.__setInstance(e, this.$i18n),
        (this.$t = (...e) => this.$i18n.t(...e)),
        (this.$rt = (...e) => this.$i18n.rt(...e)),
        (this.$tc = (...e) => this.$i18n.tc(...e)),
        (this.$te = (e, t) => this.$i18n.te(e, t)),
        (this.$d = (...e) => this.$i18n.d(...e)),
        (this.$n = (...e) => this.$i18n.n(...e)),
        (this.$tm = e => this.$i18n.tm(e));
    },
    mounted() {
      {
        this.$el.__VUE_I18N__ = this.$i18n.__composer;
        const e = (this.__v_emitter = createEmitter()),
          t = this.$i18n;
        t.__enableEmitter && t.__enableEmitter(e), e.on("*", addTimelineEvent);
      }
    },
    beforeUnmount() {
      var e = getCurrentInstance();
      if (!e) throw createI18nError(22);
      {
        this.__v_emitter &&
          (this.__v_emitter.off("*", addTimelineEvent),
          delete this.__v_emitter);
        const t = this.$i18n;
        t.__disableEmitter && t.__disableEmitter(),
          delete this.$el.__VUE_I18N__;
      }
      delete this.$t,
        delete this.$rt,
        delete this.$tc,
        delete this.$te,
        delete this.$d,
        delete this.$n,
        delete this.$tm,
        s.__deleteInstance(e),
        delete this.$i18n;
    },
  };
}
function mergeToRoot(t, a) {
  (t.locale = a.locale || t.locale),
    (t.fallbackLocale = a.fallbackLocale || t.fallbackLocale),
    (t.missing = a.missing || t.missing),
    (t.silentTranslationWarn = a.silentTranslationWarn || t.silentFallbackWarn),
    (t.silentFallbackWarn = a.silentFallbackWarn || t.silentFallbackWarn),
    (t.formatFallbackMessages =
      a.formatFallbackMessages || t.formatFallbackMessages),
    (t.postTranslation = a.postTranslation || t.postTranslation),
    (t.warnHtmlInMessage = a.warnHtmlInMessage || t.warnHtmlInMessage),
    (t.escapeParameterHtml = a.escapeParameterHtml || t.escapeParameterHtml),
    (t.sync = a.sync || t.sync),
    t.__composer[SetPluralRulesSymbol](
      a.pluralizationRules || t.pluralizationRules
    );
  const n = getLocaleMessages(t.locale, {
    messages: a.messages,
    __i18n: a.__i18n,
  });
  return (
    Object.keys(n).forEach(e => t.mergeLocaleMessage(e, n[e])),
    a.datetimeFormats &&
      Object.keys(a.datetimeFormats).forEach(e =>
        t.mergeDateTimeFormat(e, a.datetimeFormats[e])
      ),
    a.numberFormats &&
      Object.keys(a.numberFormats).forEach(e =>
        t.mergeNumberFormat(e, a.numberFormats[e])
      ),
    t
  );
}
function createI18n(e = {}) {
  const s = !isBoolean(e.legacy) || e.legacy,
    o = !!e.globalInjection,
    a = new Map(),
    i = (s ? createVueI18n : createComposer)(e),
    l = makeSymbol("vue-i18n"),
    c = {
      get mode() {
        return s ? "legacy" : "composition";
      },
      async install(e, ...t) {
        (e.__VUE_I18N__ = c),
          (e.__VUE_I18N_SYMBOL__ = l),
          e.provide(e.__VUE_I18N_SYMBOL__, c),
          !s && o && injectGlobalFields(e, c.global),
          apply(e, c, ...t),
          s && e.mixin(defineMixin(i, i.__composer, c));
        {
          if (!(await enableDevTools(e, c))) throw createI18nError(21);
          const a = createEmitter();
          if (s) {
            const n = i;
            n.__enableEmitter && n.__enableEmitter(a);
          } else {
            const r = i;
            r[EnableEmitter] && r[EnableEmitter](a);
          }
          a.on("*", addTimelineEvent);
        }
      },
      get global() {
        return i;
      },
      __instances: a,
      __getInstance(e) {
        return a.get(e) || null;
      },
      __setInstance(e, t) {
        a.set(e, t);
      },
      __deleteInstance(e) {
        a.delete(e);
      },
    };
  return c;
}
function useI18n(a = {}) {
  var n = getCurrentInstance();
  if (null == n) throw createI18nError(16);
  if (!n.appContext.app.__VUE_I18N_SYMBOL__) throw createI18nError(17);
  var t = inject(n.appContext.app.__VUE_I18N_SYMBOL__);
  if (!t) throw createI18nError(22);
  const r = "composition" === t.mode ? t.global : t.global.__composer;
  var e = isEmptyObject(a)
    ? "__i18n" in n.type
      ? "local"
      : "global"
    : a.useScope || "local";
  if ("global" === e) {
    let t = isObject(a.messages) ? a.messages : {};
    "__i18nGlobal" in n.type &&
      (t = getLocaleMessages(r.locale.value, {
        messages: t,
        __i18n: n.type.__i18nGlobal,
      }));
    const i = Object.keys(t);
    if (
      (i.length &&
        i.forEach(e => {
          r.mergeLocaleMessage(e, t[e]);
        }),
      isObject(a.datetimeFormats))
    ) {
      const l = Object.keys(a.datetimeFormats);
      l.length &&
        l.forEach(e => {
          r.mergeDateTimeFormat(e, a.datetimeFormats[e]);
        });
    }
    if (isObject(a.numberFormats)) {
      const c = Object.keys(a.numberFormats);
      c.length &&
        c.forEach(e => {
          r.mergeNumberFormat(e, a.numberFormats[e]);
        });
    }
    return r;
  }
  if ("parent" === e) {
    let e = getComposer(t, n, a.__useComponent);
    return null == e && (warn(getWarnMessage(12)), (e = r)), e;
  }
  if ("legacy" === t.mode) throw createI18nError(18);
  const s = t;
  let o = s.__getInstance(n);
  if (null == o) {
    e = n.type;
    const u = assign({}, a);
    e.__i18n && (u.__i18n = e.__i18n),
      r && (u.__root = r),
      (o = createComposer(u)),
      setupLifeCycle(s, n, o),
      s.__setInstance(n, o);
  }
  return o;
}
function getComposer(e, t, a = !1) {
  let n = null;
  var r,
    s = t.root;
  let o = t.parent;
  for (; null != o; ) {
    const i = e;
    if (
      ("composition" === e.mode
        ? (n = i.__getInstance(o))
        : (null != (r = i.__getInstance(o)) && (n = r.__composer),
          a && n && !n[InejctWithOption] && (n = null)),
      null != n)
    )
      break;
    if (s === o) break;
    o = o.parent;
  }
  return n;
}
function setupLifeCycle(t, a, n) {
  let r = null;
  onMounted(() => {
    if (a.vnode.el) {
      (a.vnode.el.__VUE_I18N__ = n), (r = createEmitter());
      const e = n;
      e[EnableEmitter] && e[EnableEmitter](r), r.on("*", addTimelineEvent);
    }
  }, a),
    onUnmounted(() => {
      if (a.vnode.el && a.vnode.el.__VUE_I18N__) {
        r && r.off("*", addTimelineEvent);
        const e = n;
        e[DisableEmitter] && e[DisableEmitter](),
          delete a.vnode.el.__VUE_I18N__;
      }
      t.__deleteInstance(a);
    }, a);
}
const globalExportProps = ["locale", "fallbackLocale", "availableLocales"],
  globalExportMethods = ["t", "rt", "d", "n", "tm"];
function injectGlobalFields(a, n) {
  const r = Object.create(null);
  globalExportProps.forEach(e => {
    const t = Object.getOwnPropertyDescriptor(n, e);
    if (!t) throw createI18nError(22);
    var a = isRef(t.value)
      ? {
          get() {
            return t.value.value;
          },
          set(e) {
            t.value.value = e;
          },
        }
      : {
          get() {
            return t.get && t.get();
          },
        };
    Object.defineProperty(r, e, a);
  }),
    (a.config.globalProperties.$i18n = r),
    globalExportMethods.forEach(e => {
      var t = Object.getOwnPropertyDescriptor(n, e);
      if (!t || !t.value) throw createI18nError(22);
      Object.defineProperty(a.config.globalProperties, "$" + e, t);
    });
}
{
  const k7 = getGlobalThis();
  (k7.__INTLIFY__ = !0), setDevToolsHook(k7.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__);
}
initDev();
export {
  DatetimeFormat,
  NumberFormat,
  Translation,
  VERSION,
  createI18n,
  useI18n,
  vTDirective,
};
